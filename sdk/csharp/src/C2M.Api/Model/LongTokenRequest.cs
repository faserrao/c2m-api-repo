// <auto-generated>
/*
 * C2M API v2 - Auth Overlay
 *
 * API for submitting documents with various routing options
 *
 * The version of the OpenAPI document: 2.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using C2M.Api.Client;

namespace C2M.Api.Model
{
    /// <summary>
    /// One of several credential mechanisms must be provided.
    /// </summary>
    public partial class LongTokenRequest : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LongTokenRequest" /> class.
        /// </summary>
        /// <param name="grantType">The authentication grant type</param>
        /// <param name="clientId">Client identifier issued by Click2Mail</param>
        /// <param name="clientSecret">Required if using client_credentials with secret</param>
        /// <param name="otpCode">Required if your policy mandates OTP for issuance</param>
        /// <param name="assertionType">Required when grant_type&#x3D;assertion</param>
        /// <param name="assertion">Signed JWT or other accepted assertion</param>
        /// <param name="scopes">Scopes to assign to the long-term token</param>
        /// <param name="ttlSeconds">Requested lifetime (1 hour - 90 days). Server may clamp.</param>
        [JsonConstructor]
        public LongTokenRequest(GrantTypeEnum grantType, string clientId, Option<string?> clientSecret = default, Option<string?> otpCode = default, Option<string?> assertionType = default, Option<string?> assertion = default, Option<List<string>?> scopes = default, Option<int?> ttlSeconds = default)
        {
            GrantType = grantType;
            ClientId = clientId;
            ClientSecretOption = clientSecret;
            OtpCodeOption = otpCode;
            AssertionTypeOption = assertionType;
            AssertionOption = assertion;
            ScopesOption = scopes;
            TtlSecondsOption = ttlSeconds;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The authentication grant type
        /// </summary>
        /// <value>The authentication grant type</value>
        public enum GrantTypeEnum
        {
            /// <summary>
            /// Enum ClientCredentials for value: client_credentials
            /// </summary>
            ClientCredentials = 1,

            /// <summary>
            /// Enum Assertion for value: assertion
            /// </summary>
            Assertion = 2
        }

        /// <summary>
        /// Returns a <see cref="GrantTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static GrantTypeEnum GrantTypeEnumFromString(string value)
        {
            if (value.Equals("client_credentials"))
                return GrantTypeEnum.ClientCredentials;

            if (value.Equals("assertion"))
                return GrantTypeEnum.Assertion;

            throw new NotImplementedException($"Could not convert value to type GrantTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="GrantTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static GrantTypeEnum? GrantTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("client_credentials"))
                return GrantTypeEnum.ClientCredentials;

            if (value.Equals("assertion"))
                return GrantTypeEnum.Assertion;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="GrantTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string GrantTypeEnumToJsonValue(GrantTypeEnum value)
        {
            if (value == GrantTypeEnum.ClientCredentials)
                return "client_credentials";

            if (value == GrantTypeEnum.Assertion)
                return "assertion";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// The authentication grant type
        /// </summary>
        /// <value>The authentication grant type</value>
        [JsonPropertyName("grant_type")]
        public GrantTypeEnum GrantType { get; set; }

        /// <summary>
        /// Client identifier issued by Click2Mail
        /// </summary>
        /// <value>Client identifier issued by Click2Mail</value>
        [JsonPropertyName("client_id")]
        public string ClientId { get; set; }

        /// <summary>
        /// Used to track the state of ClientSecret
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ClientSecretOption { get; private set; }

        /// <summary>
        /// Required if using client_credentials with secret
        /// </summary>
        /// <value>Required if using client_credentials with secret</value>
        [JsonPropertyName("client_secret")]
        public string? ClientSecret { get { return this.ClientSecretOption; } set { this.ClientSecretOption = new(value); } }

        /// <summary>
        /// Used to track the state of OtpCode
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> OtpCodeOption { get; private set; }

        /// <summary>
        /// Required if your policy mandates OTP for issuance
        /// </summary>
        /// <value>Required if your policy mandates OTP for issuance</value>
        [JsonPropertyName("otp_code")]
        public string? OtpCode { get { return this.OtpCodeOption; } set { this.OtpCodeOption = new(value); } }

        /// <summary>
        /// Used to track the state of AssertionType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AssertionTypeOption { get; private set; }

        /// <summary>
        /// Required when grant_type&#x3D;assertion
        /// </summary>
        /// <value>Required when grant_type&#x3D;assertion</value>
        [JsonPropertyName("assertion_type")]
        public string? AssertionType { get { return this.AssertionTypeOption; } set { this.AssertionTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Assertion
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AssertionOption { get; private set; }

        /// <summary>
        /// Signed JWT or other accepted assertion
        /// </summary>
        /// <value>Signed JWT or other accepted assertion</value>
        [JsonPropertyName("assertion")]
        public string? Assertion { get { return this.AssertionOption; } set { this.AssertionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Scopes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> ScopesOption { get; private set; }

        /// <summary>
        /// Scopes to assign to the long-term token
        /// </summary>
        /// <value>Scopes to assign to the long-term token</value>
        [JsonPropertyName("scopes")]
        public List<string>? Scopes { get { return this.ScopesOption; } set { this.ScopesOption = new(value); } }

        /// <summary>
        /// Used to track the state of TtlSeconds
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> TtlSecondsOption { get; private set; }

        /// <summary>
        /// Requested lifetime (1 hour - 90 days). Server may clamp.
        /// </summary>
        /// <value>Requested lifetime (1 hour - 90 days). Server may clamp.</value>
        [JsonPropertyName("ttl_seconds")]
        public int? TtlSeconds { get { return this.TtlSecondsOption; } set { this.TtlSecondsOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class LongTokenRequest {\n");
            sb.Append("  GrantType: ").Append(GrantType).Append("\n");
            sb.Append("  ClientId: ").Append(ClientId).Append("\n");
            sb.Append("  ClientSecret: ").Append(ClientSecret).Append("\n");
            sb.Append("  OtpCode: ").Append(OtpCode).Append("\n");
            sb.Append("  AssertionType: ").Append(AssertionType).Append("\n");
            sb.Append("  Assertion: ").Append(Assertion).Append("\n");
            sb.Append("  Scopes: ").Append(Scopes).Append("\n");
            sb.Append("  TtlSeconds: ").Append(TtlSeconds).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // TtlSeconds (int) maximum
            if (this.TtlSecondsOption.IsSet && this.TtlSecondsOption.Value > (int)7776000)
            {
                yield return new ValidationResult("Invalid value for TtlSeconds, must be a value less than or equal to 7776000.", new [] { "TtlSeconds" });
            }

            // TtlSeconds (int) minimum
            if (this.TtlSecondsOption.IsSet && this.TtlSecondsOption.Value < (int)3600)
            {
                yield return new ValidationResult("Invalid value for TtlSeconds, must be a value greater than or equal to 3600.", new [] { "TtlSeconds" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="LongTokenRequest" />
    /// </summary>
    public class LongTokenRequestJsonConverter : JsonConverter<LongTokenRequest>
    {
        /// <summary>
        /// Deserializes json to <see cref="LongTokenRequest" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override LongTokenRequest Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<LongTokenRequest.GrantTypeEnum?> grantType = default;
            Option<string?> clientId = default;
            Option<string?> clientSecret = default;
            Option<string?> otpCode = default;
            Option<string?> assertionType = default;
            Option<string?> assertion = default;
            Option<List<string>?> scopes = default;
            Option<int?> ttlSeconds = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "grant_type":
                            string? grantTypeRawValue = utf8JsonReader.GetString();
                            if (grantTypeRawValue != null)
                                grantType = new Option<LongTokenRequest.GrantTypeEnum?>(LongTokenRequest.GrantTypeEnumFromStringOrDefault(grantTypeRawValue));
                            break;
                        case "client_id":
                            clientId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "client_secret":
                            clientSecret = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "otp_code":
                            otpCode = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "assertion_type":
                            assertionType = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "assertion":
                            assertion = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "scopes":
                            scopes = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "ttl_seconds":
                            ttlSeconds = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!grantType.IsSet)
                throw new ArgumentException("Property is required for class LongTokenRequest.", nameof(grantType));

            if (!clientId.IsSet)
                throw new ArgumentException("Property is required for class LongTokenRequest.", nameof(clientId));

            if (grantType.IsSet && grantType.Value == null)
                throw new ArgumentNullException(nameof(grantType), "Property is not nullable for class LongTokenRequest.");

            if (clientId.IsSet && clientId.Value == null)
                throw new ArgumentNullException(nameof(clientId), "Property is not nullable for class LongTokenRequest.");

            if (clientSecret.IsSet && clientSecret.Value == null)
                throw new ArgumentNullException(nameof(clientSecret), "Property is not nullable for class LongTokenRequest.");

            if (otpCode.IsSet && otpCode.Value == null)
                throw new ArgumentNullException(nameof(otpCode), "Property is not nullable for class LongTokenRequest.");

            if (assertionType.IsSet && assertionType.Value == null)
                throw new ArgumentNullException(nameof(assertionType), "Property is not nullable for class LongTokenRequest.");

            if (assertion.IsSet && assertion.Value == null)
                throw new ArgumentNullException(nameof(assertion), "Property is not nullable for class LongTokenRequest.");

            if (scopes.IsSet && scopes.Value == null)
                throw new ArgumentNullException(nameof(scopes), "Property is not nullable for class LongTokenRequest.");

            if (ttlSeconds.IsSet && ttlSeconds.Value == null)
                throw new ArgumentNullException(nameof(ttlSeconds), "Property is not nullable for class LongTokenRequest.");

            return new LongTokenRequest(grantType.Value!.Value!, clientId.Value!, clientSecret, otpCode, assertionType, assertion, scopes, ttlSeconds);
        }

        /// <summary>
        /// Serializes a <see cref="LongTokenRequest" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="longTokenRequest"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, LongTokenRequest longTokenRequest, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, longTokenRequest, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="LongTokenRequest" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="longTokenRequest"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, LongTokenRequest longTokenRequest, JsonSerializerOptions jsonSerializerOptions)
        {
            if (longTokenRequest.ClientId == null)
                throw new ArgumentNullException(nameof(longTokenRequest.ClientId), "Property is required for class LongTokenRequest.");

            if (longTokenRequest.ClientSecretOption.IsSet && longTokenRequest.ClientSecret == null)
                throw new ArgumentNullException(nameof(longTokenRequest.ClientSecret), "Property is required for class LongTokenRequest.");

            if (longTokenRequest.OtpCodeOption.IsSet && longTokenRequest.OtpCode == null)
                throw new ArgumentNullException(nameof(longTokenRequest.OtpCode), "Property is required for class LongTokenRequest.");

            if (longTokenRequest.AssertionTypeOption.IsSet && longTokenRequest.AssertionType == null)
                throw new ArgumentNullException(nameof(longTokenRequest.AssertionType), "Property is required for class LongTokenRequest.");

            if (longTokenRequest.AssertionOption.IsSet && longTokenRequest.Assertion == null)
                throw new ArgumentNullException(nameof(longTokenRequest.Assertion), "Property is required for class LongTokenRequest.");

            if (longTokenRequest.ScopesOption.IsSet && longTokenRequest.Scopes == null)
                throw new ArgumentNullException(nameof(longTokenRequest.Scopes), "Property is required for class LongTokenRequest.");

            var grantTypeRawValue = LongTokenRequest.GrantTypeEnumToJsonValue(longTokenRequest.GrantType);
            writer.WriteString("grant_type", grantTypeRawValue);
            writer.WriteString("client_id", longTokenRequest.ClientId);

            if (longTokenRequest.ClientSecretOption.IsSet)
                writer.WriteString("client_secret", longTokenRequest.ClientSecret);

            if (longTokenRequest.OtpCodeOption.IsSet)
                writer.WriteString("otp_code", longTokenRequest.OtpCode);

            if (longTokenRequest.AssertionTypeOption.IsSet)
                writer.WriteString("assertion_type", longTokenRequest.AssertionType);

            if (longTokenRequest.AssertionOption.IsSet)
                writer.WriteString("assertion", longTokenRequest.Assertion);

            if (longTokenRequest.ScopesOption.IsSet)
            {
                writer.WritePropertyName("scopes");
                JsonSerializer.Serialize(writer, longTokenRequest.Scopes, jsonSerializerOptions);
            }
            if (longTokenRequest.TtlSecondsOption.IsSet)
                writer.WriteNumber("ttl_seconds", longTokenRequest.TtlSecondsOption.Value!.Value);
        }
    }
}
