/*
C2M API v2 - Auth Overlay

API for submitting documents with various routing options

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package c2mapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiMergeMultiDocParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	mergeMultiDocParamsRequest *MergeMultiDocParamsRequest
}

func (r ApiMergeMultiDocParamsRequest) MergeMultiDocParamsRequest(mergeMultiDocParamsRequest MergeMultiDocParamsRequest) ApiMergeMultiDocParamsRequest {
	r.mergeMultiDocParamsRequest = &mergeMultiDocParamsRequest
	return r
}

func (r ApiMergeMultiDocParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.MergeMultiDocParamsExecute(r)
}

/*
MergeMultiDocParams Operation for /jobs/multi-doc-merge

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMergeMultiDocParamsRequest
*/
func (a *DefaultAPIService) MergeMultiDocParams(ctx context.Context) ApiMergeMultiDocParamsRequest {
	return ApiMergeMultiDocParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) MergeMultiDocParamsExecute(r ApiMergeMultiDocParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MergeMultiDocParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/multi-doc-merge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mergeMultiDocParamsRequest == nil {
		return localVarReturnValue, nil, reportError("mergeMultiDocParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mergeMultiDocParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMergeMultiDocWithTemplateParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	mergeMultiDocWithTemplateParamsRequest *MergeMultiDocWithTemplateParamsRequest
}

func (r ApiMergeMultiDocWithTemplateParamsRequest) MergeMultiDocWithTemplateParamsRequest(mergeMultiDocWithTemplateParamsRequest MergeMultiDocWithTemplateParamsRequest) ApiMergeMultiDocWithTemplateParamsRequest {
	r.mergeMultiDocWithTemplateParamsRequest = &mergeMultiDocWithTemplateParamsRequest
	return r
}

func (r ApiMergeMultiDocWithTemplateParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.MergeMultiDocWithTemplateParamsExecute(r)
}

/*
MergeMultiDocWithTemplateParams Operation for /jobs/multi-doc-merge-job-template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMergeMultiDocWithTemplateParamsRequest
*/
func (a *DefaultAPIService) MergeMultiDocWithTemplateParams(ctx context.Context) ApiMergeMultiDocWithTemplateParamsRequest {
	return ApiMergeMultiDocWithTemplateParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) MergeMultiDocWithTemplateParamsExecute(r ApiMergeMultiDocWithTemplateParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MergeMultiDocWithTemplateParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/multi-doc-merge-job-template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mergeMultiDocWithTemplateParamsRequest == nil {
		return localVarReturnValue, nil, reportError("mergeMultiDocWithTemplateParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mergeMultiDocWithTemplateParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMultiPdfWithCaptureParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	multiPdfWithCaptureParamsRequest *MultiPdfWithCaptureParamsRequest
}

func (r ApiMultiPdfWithCaptureParamsRequest) MultiPdfWithCaptureParamsRequest(multiPdfWithCaptureParamsRequest MultiPdfWithCaptureParamsRequest) ApiMultiPdfWithCaptureParamsRequest {
	r.multiPdfWithCaptureParamsRequest = &multiPdfWithCaptureParamsRequest
	return r
}

func (r ApiMultiPdfWithCaptureParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.MultiPdfWithCaptureParamsExecute(r)
}

/*
MultiPdfWithCaptureParams Operation for /jobs/multi-pdf-address-capture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMultiPdfWithCaptureParamsRequest
*/
func (a *DefaultAPIService) MultiPdfWithCaptureParams(ctx context.Context) ApiMultiPdfWithCaptureParamsRequest {
	return ApiMultiPdfWithCaptureParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) MultiPdfWithCaptureParamsExecute(r ApiMultiPdfWithCaptureParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MultiPdfWithCaptureParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/multi-pdf-address-capture"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.multiPdfWithCaptureParamsRequest == nil {
		return localVarReturnValue, nil, reportError("multiPdfWithCaptureParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.multiPdfWithCaptureParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSingleDocJobParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	singleDocJobParamsRequest *SingleDocJobParamsRequest
}

func (r ApiSingleDocJobParamsRequest) SingleDocJobParamsRequest(singleDocJobParamsRequest SingleDocJobParamsRequest) ApiSingleDocJobParamsRequest {
	r.singleDocJobParamsRequest = &singleDocJobParamsRequest
	return r
}

func (r ApiSingleDocJobParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.SingleDocJobParamsExecute(r)
}

/*
SingleDocJobParams Operation for /jobs/single-doc

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSingleDocJobParamsRequest
*/
func (a *DefaultAPIService) SingleDocJobParams(ctx context.Context) ApiSingleDocJobParamsRequest {
	return ApiSingleDocJobParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) SingleDocJobParamsExecute(r ApiSingleDocJobParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SingleDocJobParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/single-doc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.singleDocJobParamsRequest == nil {
		return localVarReturnValue, nil, reportError("singleDocJobParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.singleDocJobParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSplitPdfParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	splitPdfParamsRequest *SplitPdfParamsRequest
}

func (r ApiSplitPdfParamsRequest) SplitPdfParamsRequest(splitPdfParamsRequest SplitPdfParamsRequest) ApiSplitPdfParamsRequest {
	r.splitPdfParamsRequest = &splitPdfParamsRequest
	return r
}

func (r ApiSplitPdfParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.SplitPdfParamsExecute(r)
}

/*
SplitPdfParams Operation for /jobs/single-pdf-split

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSplitPdfParamsRequest
*/
func (a *DefaultAPIService) SplitPdfParams(ctx context.Context) ApiSplitPdfParamsRequest {
	return ApiSplitPdfParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) SplitPdfParamsExecute(r ApiSplitPdfParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SplitPdfParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/single-pdf-split"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.splitPdfParamsRequest == nil {
		return localVarReturnValue, nil, reportError("splitPdfParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.splitPdfParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSplitPdfWithCaptureParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	splitPdfWithCaptureParamsRequest *SplitPdfWithCaptureParamsRequest
}

func (r ApiSplitPdfWithCaptureParamsRequest) SplitPdfWithCaptureParamsRequest(splitPdfWithCaptureParamsRequest SplitPdfWithCaptureParamsRequest) ApiSplitPdfWithCaptureParamsRequest {
	r.splitPdfWithCaptureParamsRequest = &splitPdfWithCaptureParamsRequest
	return r
}

func (r ApiSplitPdfWithCaptureParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.SplitPdfWithCaptureParamsExecute(r)
}

/*
SplitPdfWithCaptureParams Operation for /jobs/single-pdf-split-addressCapture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSplitPdfWithCaptureParamsRequest
*/
func (a *DefaultAPIService) SplitPdfWithCaptureParams(ctx context.Context) ApiSplitPdfWithCaptureParamsRequest {
	return ApiSplitPdfWithCaptureParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) SplitPdfWithCaptureParamsExecute(r ApiSplitPdfWithCaptureParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SplitPdfWithCaptureParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/single-pdf-split-addressCapture"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.splitPdfWithCaptureParamsRequest == nil {
		return localVarReturnValue, nil, reportError("splitPdfWithCaptureParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.splitPdfWithCaptureParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitMultiDocParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	submitMultiDocParamsRequest *SubmitMultiDocParamsRequest
}

func (r ApiSubmitMultiDocParamsRequest) SubmitMultiDocParamsRequest(submitMultiDocParamsRequest SubmitMultiDocParamsRequest) ApiSubmitMultiDocParamsRequest {
	r.submitMultiDocParamsRequest = &submitMultiDocParamsRequest
	return r
}

func (r ApiSubmitMultiDocParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.SubmitMultiDocParamsExecute(r)
}

/*
SubmitMultiDocParams Operation for /jobs/multi-doc

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitMultiDocParamsRequest
*/
func (a *DefaultAPIService) SubmitMultiDocParams(ctx context.Context) ApiSubmitMultiDocParamsRequest {
	return ApiSubmitMultiDocParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) SubmitMultiDocParamsExecute(r ApiSubmitMultiDocParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SubmitMultiDocParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/multi-doc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitMultiDocParamsRequest == nil {
		return localVarReturnValue, nil, reportError("submitMultiDocParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitMultiDocParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitMultiDocWithTemplateParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	submitMultiDocWithTemplateParamsRequest *SubmitMultiDocWithTemplateParamsRequest
}

func (r ApiSubmitMultiDocWithTemplateParamsRequest) SubmitMultiDocWithTemplateParamsRequest(submitMultiDocWithTemplateParamsRequest SubmitMultiDocWithTemplateParamsRequest) ApiSubmitMultiDocWithTemplateParamsRequest {
	r.submitMultiDocWithTemplateParamsRequest = &submitMultiDocWithTemplateParamsRequest
	return r
}

func (r ApiSubmitMultiDocWithTemplateParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.SubmitMultiDocWithTemplateParamsExecute(r)
}

/*
SubmitMultiDocWithTemplateParams Operation for /jobs/multi-docs-job-template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitMultiDocWithTemplateParamsRequest
*/
func (a *DefaultAPIService) SubmitMultiDocWithTemplateParams(ctx context.Context) ApiSubmitMultiDocWithTemplateParamsRequest {
	return ApiSubmitMultiDocWithTemplateParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) SubmitMultiDocWithTemplateParamsExecute(r ApiSubmitMultiDocWithTemplateParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SubmitMultiDocWithTemplateParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/multi-docs-job-template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitMultiDocWithTemplateParamsRequest == nil {
		return localVarReturnValue, nil, reportError("submitMultiDocWithTemplateParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitMultiDocWithTemplateParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitSingleDocWithTemplateParamsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	submitSingleDocWithTemplateParamsRequest *SubmitSingleDocWithTemplateParamsRequest
}

func (r ApiSubmitSingleDocWithTemplateParamsRequest) SubmitSingleDocWithTemplateParamsRequest(submitSingleDocWithTemplateParamsRequest SubmitSingleDocWithTemplateParamsRequest) ApiSubmitSingleDocWithTemplateParamsRequest {
	r.submitSingleDocWithTemplateParamsRequest = &submitSingleDocWithTemplateParamsRequest
	return r
}

func (r ApiSubmitSingleDocWithTemplateParamsRequest) Execute() (*StandardResponse, *http.Response, error) {
	return r.ApiService.SubmitSingleDocWithTemplateParamsExecute(r)
}

/*
SubmitSingleDocWithTemplateParams Operation for /jobs/single-doc-job-template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitSingleDocWithTemplateParamsRequest
*/
func (a *DefaultAPIService) SubmitSingleDocWithTemplateParams(ctx context.Context) ApiSubmitSingleDocWithTemplateParamsRequest {
	return ApiSubmitSingleDocWithTemplateParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StandardResponse
func (a *DefaultAPIService) SubmitSingleDocWithTemplateParamsExecute(r ApiSubmitSingleDocWithTemplateParamsRequest) (*StandardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SubmitSingleDocWithTemplateParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/single-doc-job-template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitSingleDocWithTemplateParamsRequest == nil {
		return localVarReturnValue, nil, reportError("submitSingleDocWithTemplateParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitSingleDocWithTemplateParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
