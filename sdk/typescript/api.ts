/* tslint:disable */
/* eslint-disable */
/**
 * C2M API v2 - Auth Overlay
 * API for submitting documents with various routing options
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AchDetails {
    'routingNumber': string;
    'accountNumber': string;
    'checkDigit': number;
}
export interface AchPayment {
    'achDetails': AchDetails;
}
export interface AddressListPdf {
    'documentSourceIdentifier': DocumentSourceIdentifier;
    'addressListRegion': string;
    'delimiter'?: string;
    'tags'?: Array<string>;
}
export interface AddressRegion {
    'x': number;
    'y': number;
    'width': number;
    'height': number;
    'pageOffset': number;
}
export interface ApplePayPayment {
    'applePaymentDetails': object;
}
export interface AuthError {
    /**
     * OAuth-style error code
     */
    'code': string;
    /**
     * Human-readable error message
     */
    'message': string;
    /**
     * Additional error details
     */
    'details'?: object;
}

export const CardType = {
    Visa: 'visa',
    Mastercard: 'mastercard',
    Discover: 'discover',
    AmericanExpress: 'americanExpress'
} as const;

export type CardType = typeof CardType[keyof typeof CardType];


export interface CreditAmount {
    'amount': number;
    'currency': Currency;
}


export interface CreditCardDetails {
    'cardType': CardType;
    'cardNumber': string;
    'expirationDate': ExpirationDate;
    'cvv': number;
}


export interface CreditCardPayment {
    'creditCardDetails': CreditCardDetails;
}

export const Currency = {
    Usd: 'USD',
    Eur: 'EUR',
    Gbp: 'GBP',
    Cad: 'CAD',
    Aud: 'AUD'
} as const;

export type Currency = typeof Currency[keyof typeof Currency];



export const Digit = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9'
} as const;

export type Digit = typeof Digit[keyof typeof Digit];



export const DocumentClass = {
    BusinessLetter: 'businessLetter',
    PersonalLetter: 'personalLetter'
} as const;

export type DocumentClass = typeof DocumentClass[keyof typeof DocumentClass];



export const DocumentFormat = {
    Pdf: 'pdf',
    Doc: 'doc',
    Docx: 'docx',
    Pub: 'pub',
    Ppt: 'ppt',
    Pptx: 'pptx',
    Png: 'png',
    Jpeg: 'jpeg',
    Odt: 'odt'
} as const;

export type DocumentFormat = typeof DocumentFormat[keyof typeof DocumentFormat];


/**
 * @type DocumentSourceIdentifier
 */
export type DocumentSourceIdentifier = DocumentSourceIdentifierOneOf | DocumentSourceIdentifierOneOf1 | DocumentSourceIdentifierOneOf2 | number | string;

export interface DocumentSourceIdentifierOneOf {
    'uploadRequestId': number;
    'documentName': string;
}
export interface DocumentSourceIdentifierOneOf1 {
    'uploadRequestId': number;
    'zipId': number;
    'documentName': string;
}
export interface DocumentSourceIdentifierOneOf2 {
    'zipId': number;
    'documentName': string;
}

export const Envelope = {
    Flat: 'flat',
    WindowedFlat: 'windowedFlat',
    Letter: 'letter',
    Legal: 'legal',
    Postcard: 'postcard'
} as const;

export type Envelope = typeof Envelope[keyof typeof Envelope];


export interface ExpirationDate {
    'month': number;
    'year': number;
}
export interface ExtractionSpec {
    'startPage': number;
    'endPage': number;
    'addressRegion': AddressRegion;
}
export interface GooglePayPayment {
    'googlePaymentDetails': object;
}
export interface InvoiceDetails {
    'invoiceNumber': string;
    'amountDue': number;
}
export interface InvoicePayment {
    'invoiceDetails': InvoiceDetails;
}
export interface JobOptions {
    'documentClass': DocumentClass;
    'layout': Layout;
    'mailclass': Mailclass;
    'paperType': PaperType;
    'printOption': PrintOption;
    'envelope': Envelope;
}



export const Layout = {
    Portrait: 'portrait',
    Landscape: 'landscape'
} as const;

export type Layout = typeof Layout[keyof typeof Layout];


/**
 * One of several credential mechanisms must be provided.
 */
export interface LongTokenRequest {
    /**
     * The authentication grant type
     */
    'grant_type': LongTokenRequestGrantTypeEnum;
    /**
     * Client identifier issued by Click2Mail
     */
    'client_id': string;
    /**
     * Required if using client_credentials with secret
     */
    'client_secret'?: string;
    /**
     * Required if your policy mandates OTP for issuance
     */
    'otp_code'?: string;
    /**
     * Required when grant_type=assertion
     */
    'assertion_type'?: string;
    /**
     * Signed JWT or other accepted assertion
     */
    'assertion'?: string;
    /**
     * Scopes to assign to the long-term token
     */
    'scopes'?: Array<string>;
    /**
     * Requested lifetime (1 hour - 90 days). Server may clamp.
     */
    'ttl_seconds'?: number;
}

export const LongTokenRequestGrantTypeEnum = {
    ClientCredentials: 'client_credentials',
    Assertion: 'assertion'
} as const;

export type LongTokenRequestGrantTypeEnum = typeof LongTokenRequestGrantTypeEnum[keyof typeof LongTokenRequestGrantTypeEnum];

export interface LongTokenResponse {
    'token_type': LongTokenResponseTokenTypeEnum;
    /**
     * Long-lived token (opaque or JWT depending on deployment)
     */
    'access_token': string;
    /**
     * Lifetime in seconds
     */
    'expires_in': number;
    /**
     * ISO 8601 timestamp of expiration
     */
    'expires_at': string;
    /**
     * Granted scopes
     */
    'scopes'?: Array<string>;
    /**
     * Server-issued identifier for this token
     */
    'token_id'?: string;
}

export const LongTokenResponseTokenTypeEnum = {
    Bearer: 'Bearer'
} as const;

export type LongTokenResponseTokenTypeEnum = typeof LongTokenResponseTokenTypeEnum[keyof typeof LongTokenResponseTokenTypeEnum];


export const Mailclass = {
    FirstClassMail: 'firstClassMail',
    PriorityMail: 'priorityMail',
    LargeEnvelope: 'largeEnvelope'
} as const;

export type Mailclass = typeof Mailclass[keyof typeof Mailclass];


export interface MergeMultiDocParams {
    'documentsToMerge': Array<DocumentSourceIdentifier>;
    'recipientAddressSource': RecipientAddressSource;
    'tags'?: Array<string>;
}
export interface MergeMultiDocParamsRequest {
    'documentsToMerge': Array<DocumentSourceIdentifier>;
    'recipientAddressSource': RecipientAddressSource;
    'tags'?: Array<string>;
}
export interface MergeMultiDocWithTemplateParams {
    'documentsToMerge': Array<DocumentSourceIdentifier>;
    'recipientAddressSource': RecipientAddressSource;
    'jobTemplate': string;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface MergeMultiDocWithTemplateParamsRequest {
    'documentsToMerge': Array<DocumentSourceIdentifier>;
    'recipientAddressSource': RecipientAddressSource;
    'jobTemplate': string;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface MultiPdfWithCaptureParams {
    'addressCapturePdfs': Array<AddressListPdf>;
    'jobTemplate': string;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface MultiPdfWithCaptureParamsRequest {
    'addressCapturePdfs': Array<AddressListPdf>;
    'jobTemplate': string;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface PageRange {
    'startPage': number;
    'endPage': number;
}

export const PaperType = {
    Letter: 'letter',
    Legal: 'legal',
    Postcard: 'postcard'
} as const;

export type PaperType = typeof PaperType[keyof typeof PaperType];


/**
 * @type PaymentDetails
 */
export type PaymentDetails = AchPayment | ApplePayPayment | CreditCardPayment | GooglePayPayment | InvoicePayment | UserCreditPayment;


export const PrintOption = {
    None: 'none',
    Color: 'color',
    Grayscale: 'grayscale'
} as const;

export type PrintOption = typeof PrintOption[keyof typeof PrintOption];


export interface RecipientAddress {
    'firstName': string;
    'lastName': string;
    'address1': string;
    'city': string;
    'state': string;
    'zip': string;
    'country': string;
    'nickName'?: string;
    'address2'?: string;
    'address3'?: string;
    'phoneNumber'?: string;
}
/**
 * @type RecipientAddressSource
 */
export type RecipientAddressSource = RecipientAddress | number;

export interface ShortTokenRequest {
    /**
     * Optional if the long-term token is provided in Authorization header
     */
    'long_token'?: string;
    /**
     * Optional scope narrowing; defaults to the long-term token\'s scopes
     */
    'scopes'?: Array<string>;
}
export interface ShortTokenResponse {
    'token_type': ShortTokenResponseTokenTypeEnum;
    /**
     * Short-lived JWT
     */
    'access_token': string;
    /**
     * Lifetime in seconds (e.g., 900 for 15 minutes)
     */
    'expires_in': number;
    /**
     * ISO 8601 timestamp of expiration
     */
    'expires_at': string;
    /**
     * Granted scopes
     */
    'scopes'?: Array<string>;
    /**
     * Server-issued identifier for this token
     */
    'token_id'?: string;
}

export const ShortTokenResponseTokenTypeEnum = {
    Bearer: 'Bearer'
} as const;

export type ShortTokenResponseTokenTypeEnum = typeof ShortTokenResponseTokenTypeEnum[keyof typeof ShortTokenResponseTokenTypeEnum];

export interface SingleDocJobParams {
    'documentSourceIdentifier': DocumentSourceIdentifier;
    'recipientAddressSources': Array<RecipientAddressSource>;
    'jobOptions': JobOptions;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SingleDocJobParamsRequest {
    'documentSourceIdentifier': DocumentSourceIdentifier;
    'recipientAddressSources': Array<RecipientAddressSource>;
    'jobOptions': JobOptions;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SplitPdfParams {
    'documentSourceIdentifier': DocumentSourceIdentifier;
    'items': Array<SplitPdfParamsRequestItemsInner>;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SplitPdfParamsRequest {
    'documentSourceIdentifier': DocumentSourceIdentifier;
    'items': Array<SplitPdfParamsRequestItemsInner>;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SplitPdfParamsRequestItemsInner {
    'pageRange': PageRange;
    'recipientAddressSources': Array<RecipientAddressSource>;
}
export interface SplitPdfWithCaptureParams {
    'documentSourceIdentifier': DocumentSourceIdentifier;
    'embeddedExtractionSpecs': Array<ExtractionSpec>;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SplitPdfWithCaptureParamsRequest {
    'documentSourceIdentifier': DocumentSourceIdentifier;
    'embeddedExtractionSpecs': Array<ExtractionSpec>;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface StandardResponse {
    'status'?: string;
    'message'?: string;
    'jobId'?: string;
}
export interface SubmitMultiDocParams {
    'items': Array<SubmitMultiDocWithTemplateParamsRequestItemsInner>;
    'jobOptions': JobOptions;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SubmitMultiDocParamsRequest {
    'items': Array<SubmitMultiDocWithTemplateParamsRequestItemsInner>;
    'jobOptions': JobOptions;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SubmitMultiDocWithTemplateParams {
    'items': Array<SubmitMultiDocWithTemplateParamsRequestItemsInner>;
    'jobTemplate': string;
    'paymentDetails': PaymentDetails;
    'tags'?: Array<string>;
}
export interface SubmitMultiDocWithTemplateParamsRequest {
    'items': Array<SubmitMultiDocWithTemplateParamsRequestItemsInner>;
    'jobTemplate': string;
    'paymentDetails': PaymentDetails;
    'tags'?: Array<string>;
}
export interface SubmitMultiDocWithTemplateParamsRequestItemsInner {
    'documentSourceIdentifier': DocumentSourceIdentifier;
    'recipientAddressSource': RecipientAddressSource;
}
export interface SubmitSingleDocWithTemplateParams {
    'jobTemplate': string;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SubmitSingleDocWithTemplateParamsRequest {
    'jobTemplate': string;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface UserCreditPayment {
    'creditAmount': CreditAmount;
}

/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - `client_credentials` + `client_secret` - `client_credentials` + one-time `otp_code` - `assertion` (e.g., signed JWT by your private key) - Or an existing short-term token with the `tokens:write` scope  Only one mechanism is required per call. 
         * @summary Issue or rotate a long-term token
         * @param {LongTokenRequest} longTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueLongTermToken: async (longTokenRequest: LongTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longTokenRequest' is not null or undefined
            assertParamExists('issueLongTermToken', 'longTokenRequest', longTokenRequest)
            const localVarPath = `/auth/tokens/long`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ShortTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication ClientKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(longTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as `Bearer <long_token>`. 
         * @summary Issue a short-term access token
         * @param {ShortTokenRequest} [shortTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueShortTermToken: async (shortTokenRequest?: ShortTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/tokens/short`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication LongTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shortTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes a short- or long-term token by its `tokenId`. Idempotent.
         * @summary Revoke a token
         * @param {string} tokenId The token ID to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: async (tokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('revokeToken', 'tokenId', tokenId)
            const localVarPath = `/auth/tokens/{tokenId}/revoke`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication LongTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication ShortTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - `client_credentials` + `client_secret` - `client_credentials` + one-time `otp_code` - `assertion` (e.g., signed JWT by your private key) - Or an existing short-term token with the `tokens:write` scope  Only one mechanism is required per call. 
         * @summary Issue or rotate a long-term token
         * @param {LongTokenRequest} longTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueLongTermToken(longTokenRequest: LongTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LongTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueLongTermToken(longTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.issueLongTermToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as `Bearer <long_token>`. 
         * @summary Issue a short-term access token
         * @param {ShortTokenRequest} [shortTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueShortTermToken(shortTokenRequest?: ShortTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueShortTermToken(shortTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.issueShortTermToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revokes a short- or long-term token by its `tokenId`. Idempotent.
         * @summary Revoke a token
         * @param {string} tokenId The token ID to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeToken(tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeToken(tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.revokeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - `client_credentials` + `client_secret` - `client_credentials` + one-time `otp_code` - `assertion` (e.g., signed JWT by your private key) - Or an existing short-term token with the `tokens:write` scope  Only one mechanism is required per call. 
         * @summary Issue or rotate a long-term token
         * @param {LongTokenRequest} longTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueLongTermToken(longTokenRequest: LongTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<LongTokenResponse> {
            return localVarFp.issueLongTermToken(longTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as `Bearer <long_token>`. 
         * @summary Issue a short-term access token
         * @param {ShortTokenRequest} [shortTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueShortTermToken(shortTokenRequest?: ShortTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShortTokenResponse> {
            return localVarFp.issueShortTermToken(shortTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes a short- or long-term token by its `tokenId`. Idempotent.
         * @summary Revoke a token
         * @param {string} tokenId The token ID to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeToken(tokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - `client_credentials` + `client_secret` - `client_credentials` + one-time `otp_code` - `assertion` (e.g., signed JWT by your private key) - Or an existing short-term token with the `tokens:write` scope  Only one mechanism is required per call. 
     * @summary Issue or rotate a long-term token
     * @param {LongTokenRequest} longTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public issueLongTermToken(longTokenRequest: LongTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).issueLongTermToken(longTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as `Bearer <long_token>`. 
     * @summary Issue a short-term access token
     * @param {ShortTokenRequest} [shortTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public issueShortTermToken(shortTokenRequest?: ShortTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).issueShortTermToken(shortTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes a short- or long-term token by its `tokenId`. Idempotent.
     * @summary Revoke a token
     * @param {string} tokenId The token ID to revoke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeToken(tokenId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).revokeToken(tokenId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Operation for /jobs/multi-doc-merge
         * @param {MergeMultiDocParamsRequest} mergeMultiDocParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeMultiDocParams: async (mergeMultiDocParamsRequest: MergeMultiDocParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mergeMultiDocParamsRequest' is not null or undefined
            assertParamExists('mergeMultiDocParams', 'mergeMultiDocParamsRequest', mergeMultiDocParamsRequest)
            const localVarPath = `/jobs/multi-doc-merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeMultiDocParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Operation for /jobs/multi-doc-merge-job-template
         * @param {MergeMultiDocWithTemplateParamsRequest} mergeMultiDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeMultiDocWithTemplateParams: async (mergeMultiDocWithTemplateParamsRequest: MergeMultiDocWithTemplateParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mergeMultiDocWithTemplateParamsRequest' is not null or undefined
            assertParamExists('mergeMultiDocWithTemplateParams', 'mergeMultiDocWithTemplateParamsRequest', mergeMultiDocWithTemplateParamsRequest)
            const localVarPath = `/jobs/multi-doc-merge-job-template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeMultiDocWithTemplateParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Operation for /jobs/multi-pdf-address-capture
         * @param {MultiPdfWithCaptureParamsRequest} multiPdfWithCaptureParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        multiPdfWithCaptureParams: async (multiPdfWithCaptureParamsRequest: MultiPdfWithCaptureParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'multiPdfWithCaptureParamsRequest' is not null or undefined
            assertParamExists('multiPdfWithCaptureParams', 'multiPdfWithCaptureParamsRequest', multiPdfWithCaptureParamsRequest)
            const localVarPath = `/jobs/multi-pdf-address-capture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multiPdfWithCaptureParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Operation for /jobs/single-doc
         * @param {SingleDocJobParamsRequest} singleDocJobParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singleDocJobParams: async (singleDocJobParamsRequest: SingleDocJobParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'singleDocJobParamsRequest' is not null or undefined
            assertParamExists('singleDocJobParams', 'singleDocJobParamsRequest', singleDocJobParamsRequest)
            const localVarPath = `/jobs/single-doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(singleDocJobParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Operation for /jobs/single-pdf-split
         * @param {SplitPdfParamsRequest} splitPdfParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitPdfParams: async (splitPdfParamsRequest: SplitPdfParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'splitPdfParamsRequest' is not null or undefined
            assertParamExists('splitPdfParams', 'splitPdfParamsRequest', splitPdfParamsRequest)
            const localVarPath = `/jobs/single-pdf-split`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(splitPdfParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Operation for /jobs/single-pdf-split-addressCapture
         * @param {SplitPdfWithCaptureParamsRequest} splitPdfWithCaptureParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitPdfWithCaptureParams: async (splitPdfWithCaptureParamsRequest: SplitPdfWithCaptureParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'splitPdfWithCaptureParamsRequest' is not null or undefined
            assertParamExists('splitPdfWithCaptureParams', 'splitPdfWithCaptureParamsRequest', splitPdfWithCaptureParamsRequest)
            const localVarPath = `/jobs/single-pdf-split-addressCapture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(splitPdfWithCaptureParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Operation for /jobs/multi-doc
         * @param {SubmitMultiDocParamsRequest} submitMultiDocParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiDocParams: async (submitMultiDocParamsRequest: SubmitMultiDocParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitMultiDocParamsRequest' is not null or undefined
            assertParamExists('submitMultiDocParams', 'submitMultiDocParamsRequest', submitMultiDocParamsRequest)
            const localVarPath = `/jobs/multi-doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitMultiDocParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Operation for /jobs/multi-docs-job-template
         * @param {SubmitMultiDocWithTemplateParamsRequest} submitMultiDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiDocWithTemplateParams: async (submitMultiDocWithTemplateParamsRequest: SubmitMultiDocWithTemplateParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitMultiDocWithTemplateParamsRequest' is not null or undefined
            assertParamExists('submitMultiDocWithTemplateParams', 'submitMultiDocWithTemplateParamsRequest', submitMultiDocWithTemplateParamsRequest)
            const localVarPath = `/jobs/multi-docs-job-template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitMultiDocWithTemplateParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Operation for /jobs/single-doc-job-template
         * @param {SubmitSingleDocWithTemplateParamsRequest} submitSingleDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSingleDocWithTemplateParams: async (submitSingleDocWithTemplateParamsRequest: SubmitSingleDocWithTemplateParamsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitSingleDocWithTemplateParamsRequest' is not null or undefined
            assertParamExists('submitSingleDocWithTemplateParams', 'submitSingleDocWithTemplateParamsRequest', submitSingleDocWithTemplateParamsRequest)
            const localVarPath = `/jobs/single-doc-job-template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitSingleDocWithTemplateParamsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Operation for /jobs/multi-doc-merge
         * @param {MergeMultiDocParamsRequest} mergeMultiDocParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeMultiDocParams(mergeMultiDocParamsRequest: MergeMultiDocParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeMultiDocParams(mergeMultiDocParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mergeMultiDocParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Operation for /jobs/multi-doc-merge-job-template
         * @param {MergeMultiDocWithTemplateParamsRequest} mergeMultiDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeMultiDocWithTemplateParams(mergeMultiDocWithTemplateParamsRequest: MergeMultiDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeMultiDocWithTemplateParams(mergeMultiDocWithTemplateParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mergeMultiDocWithTemplateParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Operation for /jobs/multi-pdf-address-capture
         * @param {MultiPdfWithCaptureParamsRequest} multiPdfWithCaptureParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async multiPdfWithCaptureParams(multiPdfWithCaptureParamsRequest: MultiPdfWithCaptureParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.multiPdfWithCaptureParams(multiPdfWithCaptureParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.multiPdfWithCaptureParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Operation for /jobs/single-doc
         * @param {SingleDocJobParamsRequest} singleDocJobParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async singleDocJobParams(singleDocJobParamsRequest: SingleDocJobParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.singleDocJobParams(singleDocJobParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.singleDocJobParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Operation for /jobs/single-pdf-split
         * @param {SplitPdfParamsRequest} splitPdfParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitPdfParams(splitPdfParamsRequest: SplitPdfParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitPdfParams(splitPdfParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.splitPdfParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Operation for /jobs/single-pdf-split-addressCapture
         * @param {SplitPdfWithCaptureParamsRequest} splitPdfWithCaptureParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitPdfWithCaptureParams(splitPdfWithCaptureParamsRequest: SplitPdfWithCaptureParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitPdfWithCaptureParams(splitPdfWithCaptureParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.splitPdfWithCaptureParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Operation for /jobs/multi-doc
         * @param {SubmitMultiDocParamsRequest} submitMultiDocParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMultiDocParams(submitMultiDocParamsRequest: SubmitMultiDocParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitMultiDocParams(submitMultiDocParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.submitMultiDocParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Operation for /jobs/multi-docs-job-template
         * @param {SubmitMultiDocWithTemplateParamsRequest} submitMultiDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMultiDocWithTemplateParams(submitMultiDocWithTemplateParamsRequest: SubmitMultiDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitMultiDocWithTemplateParams(submitMultiDocWithTemplateParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.submitMultiDocWithTemplateParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Operation for /jobs/single-doc-job-template
         * @param {SubmitSingleDocWithTemplateParamsRequest} submitSingleDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSingleDocWithTemplateParams(submitSingleDocWithTemplateParamsRequest: SubmitSingleDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitSingleDocWithTemplateParams(submitSingleDocWithTemplateParamsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.submitSingleDocWithTemplateParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Operation for /jobs/multi-doc-merge
         * @param {MergeMultiDocParamsRequest} mergeMultiDocParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeMultiDocParams(mergeMultiDocParamsRequest: MergeMultiDocParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.mergeMultiDocParams(mergeMultiDocParamsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Operation for /jobs/multi-doc-merge-job-template
         * @param {MergeMultiDocWithTemplateParamsRequest} mergeMultiDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeMultiDocWithTemplateParams(mergeMultiDocWithTemplateParamsRequest: MergeMultiDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.mergeMultiDocWithTemplateParams(mergeMultiDocWithTemplateParamsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Operation for /jobs/multi-pdf-address-capture
         * @param {MultiPdfWithCaptureParamsRequest} multiPdfWithCaptureParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        multiPdfWithCaptureParams(multiPdfWithCaptureParamsRequest: MultiPdfWithCaptureParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.multiPdfWithCaptureParams(multiPdfWithCaptureParamsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Operation for /jobs/single-doc
         * @param {SingleDocJobParamsRequest} singleDocJobParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singleDocJobParams(singleDocJobParamsRequest: SingleDocJobParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.singleDocJobParams(singleDocJobParamsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Operation for /jobs/single-pdf-split
         * @param {SplitPdfParamsRequest} splitPdfParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitPdfParams(splitPdfParamsRequest: SplitPdfParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.splitPdfParams(splitPdfParamsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Operation for /jobs/single-pdf-split-addressCapture
         * @param {SplitPdfWithCaptureParamsRequest} splitPdfWithCaptureParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitPdfWithCaptureParams(splitPdfWithCaptureParamsRequest: SplitPdfWithCaptureParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.splitPdfWithCaptureParams(splitPdfWithCaptureParamsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Operation for /jobs/multi-doc
         * @param {SubmitMultiDocParamsRequest} submitMultiDocParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiDocParams(submitMultiDocParamsRequest: SubmitMultiDocParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitMultiDocParams(submitMultiDocParamsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Operation for /jobs/multi-docs-job-template
         * @param {SubmitMultiDocWithTemplateParamsRequest} submitMultiDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiDocWithTemplateParams(submitMultiDocWithTemplateParamsRequest: SubmitMultiDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitMultiDocWithTemplateParams(submitMultiDocWithTemplateParamsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Operation for /jobs/single-doc-job-template
         * @param {SubmitSingleDocWithTemplateParamsRequest} submitSingleDocWithTemplateParamsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSingleDocWithTemplateParams(submitSingleDocWithTemplateParamsRequest: SubmitSingleDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitSingleDocWithTemplateParams(submitSingleDocWithTemplateParamsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Operation for /jobs/multi-doc-merge
     * @param {MergeMultiDocParamsRequest} mergeMultiDocParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mergeMultiDocParams(mergeMultiDocParamsRequest: MergeMultiDocParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mergeMultiDocParams(mergeMultiDocParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Operation for /jobs/multi-doc-merge-job-template
     * @param {MergeMultiDocWithTemplateParamsRequest} mergeMultiDocWithTemplateParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mergeMultiDocWithTemplateParams(mergeMultiDocWithTemplateParamsRequest: MergeMultiDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mergeMultiDocWithTemplateParams(mergeMultiDocWithTemplateParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Operation for /jobs/multi-pdf-address-capture
     * @param {MultiPdfWithCaptureParamsRequest} multiPdfWithCaptureParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public multiPdfWithCaptureParams(multiPdfWithCaptureParamsRequest: MultiPdfWithCaptureParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).multiPdfWithCaptureParams(multiPdfWithCaptureParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Operation for /jobs/single-doc
     * @param {SingleDocJobParamsRequest} singleDocJobParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public singleDocJobParams(singleDocJobParamsRequest: SingleDocJobParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).singleDocJobParams(singleDocJobParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Operation for /jobs/single-pdf-split
     * @param {SplitPdfParamsRequest} splitPdfParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public splitPdfParams(splitPdfParamsRequest: SplitPdfParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).splitPdfParams(splitPdfParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Operation for /jobs/single-pdf-split-addressCapture
     * @param {SplitPdfWithCaptureParamsRequest} splitPdfWithCaptureParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public splitPdfWithCaptureParams(splitPdfWithCaptureParamsRequest: SplitPdfWithCaptureParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).splitPdfWithCaptureParams(splitPdfWithCaptureParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Operation for /jobs/multi-doc
     * @param {SubmitMultiDocParamsRequest} submitMultiDocParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitMultiDocParams(submitMultiDocParamsRequest: SubmitMultiDocParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitMultiDocParams(submitMultiDocParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Operation for /jobs/multi-docs-job-template
     * @param {SubmitMultiDocWithTemplateParamsRequest} submitMultiDocWithTemplateParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitMultiDocWithTemplateParams(submitMultiDocWithTemplateParamsRequest: SubmitMultiDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitMultiDocWithTemplateParams(submitMultiDocWithTemplateParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Operation for /jobs/single-doc-job-template
     * @param {SubmitSingleDocWithTemplateParamsRequest} submitSingleDocWithTemplateParamsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitSingleDocWithTemplateParams(submitSingleDocWithTemplateParamsRequest: SubmitSingleDocWithTemplateParamsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitSingleDocWithTemplateParams(submitSingleDocWithTemplateParamsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



